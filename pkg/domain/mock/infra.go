// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/nounify/pkg/domain/interfaces"
	"github.com/m-mizutani/opac"
	"github.com/slack-go/slack"
	"sync"
)

// Ensure, that SlackMock does implement interfaces.Slack.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Slack = &SlackMock{}

// SlackMock is a mock implementation of interfaces.Slack.
//
//	func TestSomethingThatUsesSlack(t *testing.T) {
//
//		// make and configure a mocked interfaces.Slack
//		mockedSlack := &SlackMock{
//			PostMessageContextFunc: func(ctx context.Context, channelID string, options ...slack.MsgOption) (string, string, error) {
//				panic("mock out the PostMessageContext method")
//			},
//		}
//
//		// use mockedSlack in code that requires interfaces.Slack
//		// and then make assertions.
//
//	}
type SlackMock struct {
	// PostMessageContextFunc mocks the PostMessageContext method.
	PostMessageContextFunc func(ctx context.Context, channelID string, options ...slack.MsgOption) (string, string, error)

	// calls tracks calls to the methods.
	calls struct {
		// PostMessageContext holds details about calls to the PostMessageContext method.
		PostMessageContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// Options is the options argument value.
			Options []slack.MsgOption
		}
	}
	lockPostMessageContext sync.RWMutex
}

// PostMessageContext calls PostMessageContextFunc.
func (mock *SlackMock) PostMessageContext(ctx context.Context, channelID string, options ...slack.MsgOption) (string, string, error) {
	if mock.PostMessageContextFunc == nil {
		panic("SlackMock.PostMessageContextFunc: method is nil but Slack.PostMessageContext was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		Options   []slack.MsgOption
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		Options:   options,
	}
	mock.lockPostMessageContext.Lock()
	mock.calls.PostMessageContext = append(mock.calls.PostMessageContext, callInfo)
	mock.lockPostMessageContext.Unlock()
	return mock.PostMessageContextFunc(ctx, channelID, options...)
}

// PostMessageContextCalls gets all the calls that were made to PostMessageContext.
// Check the length with:
//
//	len(mockedSlack.PostMessageContextCalls())
func (mock *SlackMock) PostMessageContextCalls() []struct {
	Ctx       context.Context
	ChannelID string
	Options   []slack.MsgOption
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		Options   []slack.MsgOption
	}
	mock.lockPostMessageContext.RLock()
	calls = mock.calls.PostMessageContext
	mock.lockPostMessageContext.RUnlock()
	return calls
}

// Ensure, that PolicyMock does implement interfaces.Policy.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Policy = &PolicyMock{}

// PolicyMock is a mock implementation of interfaces.Policy.
//
//	func TestSomethingThatUsesPolicy(t *testing.T) {
//
//		// make and configure a mocked interfaces.Policy
//		mockedPolicy := &PolicyMock{
//			QueryFunc: func(ctx context.Context, query string, input any, output any, options ...opac.QueryOption) error {
//				panic("mock out the Query method")
//			},
//		}
//
//		// use mockedPolicy in code that requires interfaces.Policy
//		// and then make assertions.
//
//	}
type PolicyMock struct {
	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, query string, input any, output any, options ...opac.QueryOption) error

	// calls tracks calls to the methods.
	calls struct {
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Input is the input argument value.
			Input any
			// Output is the output argument value.
			Output any
			// Options is the options argument value.
			Options []opac.QueryOption
		}
	}
	lockQuery sync.RWMutex
}

// Query calls QueryFunc.
func (mock *PolicyMock) Query(ctx context.Context, query string, input any, output any, options ...opac.QueryOption) error {
	if mock.QueryFunc == nil {
		panic("PolicyMock.QueryFunc: method is nil but Policy.Query was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Query   string
		Input   any
		Output  any
		Options []opac.QueryOption
	}{
		Ctx:     ctx,
		Query:   query,
		Input:   input,
		Output:  output,
		Options: options,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(ctx, query, input, output, options...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedPolicy.QueryCalls())
func (mock *PolicyMock) QueryCalls() []struct {
	Ctx     context.Context
	Query   string
	Input   any
	Output  any
	Options []opac.QueryOption
} {
	var calls []struct {
		Ctx     context.Context
		Query   string
		Input   any
		Output  any
		Options []opac.QueryOption
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}
