// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/nounify/pkg/domain/interfaces"
	"github.com/m-mizutani/nounify/pkg/domain/model"
	"github.com/m-mizutani/nounify/pkg/domain/types"
	"sync"
)

// Ensure, that UseCasesMock does implement interfaces.UseCases.
// If this is not the case, regenerate this file with moq.
var _ interfaces.UseCases = &UseCasesMock{}

// UseCasesMock is a mock implementation of interfaces.UseCases.
//
//	func TestSomethingThatUsesUseCases(t *testing.T) {
//
//		// make and configure a mocked interfaces.UseCases
//		mockedUseCases := &UseCasesMock{
//			HandleMessageFunc: func(ctx context.Context, schema types.Schema, input *model.MessageQueryInput) error {
//				panic("mock out the HandleMessage method")
//			},
//		}
//
//		// use mockedUseCases in code that requires interfaces.UseCases
//		// and then make assertions.
//
//	}
type UseCasesMock struct {
	// HandleMessageFunc mocks the HandleMessage method.
	HandleMessageFunc func(ctx context.Context, schema types.Schema, input *model.MessageQueryInput) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleMessage holds details about calls to the HandleMessage method.
		HandleMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Schema is the schema argument value.
			Schema types.Schema
			// Input is the input argument value.
			Input *model.MessageQueryInput
		}
	}
	lockHandleMessage sync.RWMutex
}

// HandleMessage calls HandleMessageFunc.
func (mock *UseCasesMock) HandleMessage(ctx context.Context, schema types.Schema, input *model.MessageQueryInput) error {
	if mock.HandleMessageFunc == nil {
		panic("UseCasesMock.HandleMessageFunc: method is nil but UseCases.HandleMessage was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Schema types.Schema
		Input  *model.MessageQueryInput
	}{
		Ctx:    ctx,
		Schema: schema,
		Input:  input,
	}
	mock.lockHandleMessage.Lock()
	mock.calls.HandleMessage = append(mock.calls.HandleMessage, callInfo)
	mock.lockHandleMessage.Unlock()
	return mock.HandleMessageFunc(ctx, schema, input)
}

// HandleMessageCalls gets all the calls that were made to HandleMessage.
// Check the length with:
//
//	len(mockedUseCases.HandleMessageCalls())
func (mock *UseCasesMock) HandleMessageCalls() []struct {
	Ctx    context.Context
	Schema types.Schema
	Input  *model.MessageQueryInput
} {
	var calls []struct {
		Ctx    context.Context
		Schema types.Schema
		Input  *model.MessageQueryInput
	}
	mock.lockHandleMessage.RLock()
	calls = mock.calls.HandleMessage
	mock.lockHandleMessage.RUnlock()
	return calls
}
